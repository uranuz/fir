Оживление компонента на клиенте после рендеринга на сервере состоит из нескольких шагов:
1. Поиск корневых тегов всех компонентов в верстке от заданного корня.
2. Создание иерархии экземпляров класса ControlReviveState, содержащих состояния всех оживляемых компонентов, найденных в верстке
3. Получение названий JavaScript компонентов и "сырых" опций и помещение их в опции jsModuleName, rawOpts, соответственно, в ControlReviveState
4. Получаем список путей всех JavaScript-модулей из дерева оживляемых компонентов и запоминаем их количество в счётчике
5. Отправляем запросы на загрузку всех JavaScript-модулей компонентов. Подписываемся на результат/ ошибку загрузки JS-модуля
6. При загрузке/ ошибке загрузке JS-модуля уменьшаем счётчик.
7. Если JS-модуль загружен устанавливаем его в опцию jsControlClass в ControlReviveState соответствующего компонента
8. Необходимо десеарилизовать сырые опции их rawOpts для всех компонентов
8. Вызываем конструкторы компонентов, начиная с "наиболее вложенных", передавая туда десериализованные опции. В конструкторе с версткой работать нельзя еще
9. -- Здесь при создании/ обновлении класса на клиенте идет генерация верстки
10. -- Здесь также может идти замена верстки при обновлении. Верстка меняется только для корневого обновляемого элемента, т.к. остальная верстка дочерних контролов там уже содержится
11. Для всех контролов устанавливаем новый корневой элемент (контейнер)
12. -- При обновлении контролов где-то здесь мы понимаем, какие дочерние контролы "пропали" из верстки. У них необходимо вызвать .destroy(). Затем сигнализировать классу-родителю, что он удалил из себя ссылку на "ребенка"
13. Срабатывание "хука", либо события об обновлении верстки типа _afterUpdate, где можно выполнить операции зависящие от верстки
14. Создание контролов завершено! Ура!


